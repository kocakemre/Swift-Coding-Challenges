{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf810
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\froman\fcharset0 Times-Roman;\f2\froman\fcharset0 TimesNewRomanPSMT;
\f3\fmodern\fcharset0 Courier-Bold;\f4\fmodern\fcharset0 Courier;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red0\green0\blue120;\red163\green0\blue79;
\red255\green255\blue255;\red107\green0\blue109;\red135\green135\blue135;\red0\green0\blue255;\red73\green17\blue135;
\red148\green108\blue71;\red28\green117\blue20;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;\cssrgb\c0\c0\c54510;\cssrgb\c70588\c0\c38431;
\cssrgb\c100000\c100000\c100000;\cssrgb\c50196\c0\c50196;\cssrgb\c60000\c60000\c60000;\cssrgb\c0\c0\c100000;\cssrgb\c36078\c14902\c60000;
\cssrgb\c65098\c49804\c34902;\cssrgb\c11373\c52157\c9804;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid101\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid2}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}}
\margl1440\margr1440\vieww15300\viewh16500\viewkind0
\deftab720
\pard\pardeftab720\sl560\sa240\partightenfactor0

\f0\b\fs48 \cf2 \expnd0\expndtw0\kerning0
Challenge 50: Count the largest range 
\f1\b0\fs24 \
\pard\pardeftab720\sl360\sa240\partightenfactor0

\b\fs32 \cf2 Difficulty: 
\f2\b0 Tricky 
\f1\fs24 \

\f2\fs32 Write a function that accepts an array of positive and negative numbers and returns a closed range containing the position of the contiguous positive numbers that sum to the highest value, or nil if nothing were found. 
\f1\fs24 \
\pard\pardeftab720\sl440\sa240\partightenfactor0

\f0\b\fs37\fsmilli18667 \cf2 Sample input and output 
\f1\b0\fs24 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl360\sa320\partightenfactor0
\ls1\ilvl0
\f2\fs32 \cf2 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
The array 
\f3\b \cf3 [0, 1, 1, -1, 2, 3, 1] 
\f2\b0 \cf2 should return 
\f3\b \cf3 4...6 
\f2\b0 \cf2 because the highest sum of contiguous positive numbers is 2 + 3 + 1, which lie at positions 4, 5, and 6 in the array. \uc0\u8232 \
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
The array 
\f3\b \cf3 [10, 20, 30, -10, -20, 10, 20] 
\f2\b0 \cf2 should return 
\f3\b \cf3 0...2
\f2\b0 \cf2 . \uc0\u8232 \
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
The array 
\f3\b \cf3 [1, -1, 2, -1] 
\f2\b0 \cf2 should return 
\f3\b \cf3 2...2
\f2\b0 \cf2 . \uc0\u8232 \
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
The array 
\f3\b \cf3 [2, 0, 2, 0, 2] 
\f2\b0 \cf2 should return 
\f3\b \cf3 0...0
\f2\b0 \cf2 . \uc0\u8232 \
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
The array 
\f3\b \cf3 [Int]() 
\f2\b0 \cf2 should return nil. \uc0\u8232 
\f0\b\fs37\fsmilli18667 Hints 
\f2\b0\fs32 \uc0\u8232 
\f1\b Hint #1: 
\f2\b0 This challenge is best solved using a little trial and error \'96 start by writing tests to ensure your solution is good as you work. \uc0\u8232 
\f1\b Hint #2: 
\f2\b0 Your return type should be 
\f3\b \cf3 CountableClosedRange<Int>? 
\f2\b0 \cf2 because there might not be any ranges of positive numbers. \uc0\u8232 
\f1\b Hint #3: 
\f2\b0 This would be a good time to use 
\f3\b \cf3 enumerated() 
\f2\b0 \cf2 to retrieve items and their index from a collection. \uc0\u8232 
\f1\b Hint #4: 
\f2\b0 There are two very different cases: if a number is greater than 0, and \'93everything else\'94. The index you return needs to be different, because a positive integer you find might be the last one in the array. \uc0\u8232 \
\pard\pardeftab720\sl440\sa240\partightenfactor0

\f0\b\fs37\fsmilli18667 \cf2 Solution 
\f1\b0\fs24 \
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f2\fs32 \cf2 There might be clever solutions to this problem, but I went straight for a brute force approach in my own solution. 
\f1\fs24 \

\f2\fs32 I solved it like this: 
\f1\fs24 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl360\sa320\partightenfactor0
\ls2\ilvl0
\f2\fs32 \cf2 \kerning1\expnd0\expndtw0 {\listtext	1.	}\expnd0\expndtw0\kerning0
Create variables for the best range and best sum, as well as the start of the current range and the current sum. \uc0\u8232 \
\ls2\ilvl0\kerning1\expnd0\expndtw0 {\listtext	2.	}\expnd0\expndtw0\kerning0
Loop over the input numbers using 
\f3\b \cf3 enumerated() 
\f2\b0 \cf2 to get the index and number in each loop. \uc0\u8232 \
\ls2\ilvl0\kerning1\expnd0\expndtw0 {\listtext	3.	}\expnd0\expndtw0\kerning0
If the number is greater than zero, and the current range start is not nil, set the current range start to be the array index and add the number to the current sum. \uc0\u8232 \
\ls2\ilvl0\kerning1\expnd0\expndtw0 {\listtext	4.	}\expnd0\expndtw0\kerning0
If this new sum is better than the existing sum, update the best range to include this new number. \uc0\u8232 \
\ls2\ilvl0\kerning1\expnd0\expndtw0 {\listtext	5.	}\expnd0\expndtw0\kerning0
If we encounter a negative number, clear the current sum and current range start variables. \uc0\u8232 \
\pard\pardeftab720\sl360\sa240\partightenfactor0
\cf2 To make the code a little neater, I used nil coalescing to set the current range start integer to itself or the array index depending on whether it has a value already. 
\f1\fs24 \

\f2\fs32 Here\'92s my code: 
\f1\fs24 \
\pard\pardeftab720\sl360\partightenfactor0

\f4\fs32 \cf4 \cb5 func \cf6 challenge50\cf7 (\cf8 _ \cf2 numbers\cf7 : [\cf9 Int\cf7 ]) \cf10 ->\
\cf9 CountableClosedRange\cf10 <\cf9 Int\cf10 >? \cf7 \{\
\pard\pardeftab720\sl360\partightenfactor0
\cf11    // this is the return value, nil by default\
\pard\pardeftab720\sl360\partightenfactor0
\cf4    var \cf2 bestRange\cf7 : \cf9 CountableClosedRange\cf10 <\cf9 Int\cf10 >? = \cf8 nil\
\cf4    var \cf2 bestSum \cf10 = \cf8 0\
\pard\pardeftab720\sl360\partightenfactor0
\cf11    // these track the current sequence of positive integers\
\pard\pardeftab720\sl360\partightenfactor0
\cf4    var \cf2 currentStart\cf7 : \cf9 Int\cf10 ? = \cf8 nil\
\cf4    var \cf2 currentSum \cf10 = \cf8 0\
\cf4    for \cf7 (\cf2 index\cf7 , \cf2 number\cf7 ) \cf4 in \cf2 numbers\cf7 .\cf6 enumerated\cf7 () \{\
\cf4       if \cf2 number \cf10 > \cf8 0 \cf7 \{\
\pard\pardeftab720\sl360\partightenfactor0
\cf11          // if we don't have a start for the current range, set one now 
\f1\fs24 \cf2 \cb1 \
\pard\pardeftab720\sl360\partightenfactor0

\f4\fs32 \cf2 \cb5 currentStart \cf10 = \cf2 currentStart \cf10 ?? \cf2 index\
currentSum \cf10 += \cf2 number\
\cf4 if \cf2 currentSum \cf10 > \cf2 bestSum \cf7 \{\
\pard\pardeftab720\sl360\partightenfactor0
\cf11    // update our best range\
\pard\pardeftab720\sl360\partightenfactor0
\cf2    bestRange \cf10 = \cf2 currentStart\cf10 ! \cf7 ... \cf2 index\
   bestSum \cf10 = \cf2 currentSum\
\pard\pardeftab720\sl360\sa240\partightenfactor0
\cf7 \}\cb1 \uc0\u8232 \cb5 \} \cf4 else \cf7 \{ 
\f1\fs24 \cf2 \cb1 \
\pard\pardeftab720\sl360\partightenfactor0

\f4\fs32 \cf11 \cb5          // reset the current range\
\pard\pardeftab720\sl360\partightenfactor0
\cf2          currentSum \cf10 = \cf8 0\
\cf2          currentStart \cf10 = \cf8 nil\
\cf7       \}\
\pard\pardeftab720\sl360\sa240\partightenfactor0
\cf7 \} 
\f1\fs24 \cf2 \cb1 \
\pard\pardeftab720\sl360\partightenfactor0

\f4\fs32 \cf4 \cb5    return \cf2 bestRange\
\cf7 \}\
}