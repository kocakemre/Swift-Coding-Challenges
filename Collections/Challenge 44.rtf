{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf810
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\froman\fcharset0 Times-Roman;\f2\froman\fcharset0 TimesNewRomanPSMT;
\f3\fmodern\fcharset0 Courier-Bold;\f4\fmodern\fcharset0 Courier;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red0\green0\blue120;\red163\green0\blue79;
\red255\green255\blue255;\red135\green135\blue135;\red73\green17\blue135;\red148\green108\blue71;\red0\green0\blue255;
}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;\cssrgb\c0\c0\c54510;\cssrgb\c70588\c0\c38431;
\cssrgb\c100000\c100000\c100000;\cssrgb\c60000\c60000\c60000;\cssrgb\c36078\c14902\c60000;\cssrgb\c65098\c49804\c34902;\cssrgb\c0\c0\c100000;
}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\margl1440\margr1440\vieww15300\viewh16500\viewkind0
\deftab720
\pard\pardeftab720\sl560\sa240\partightenfactor0

\f0\b\fs48 \cf2 \expnd0\expndtw0\kerning0
Challenge 44: Linked list mid-point 
\f1\b0\fs24 \
\pard\pardeftab720\sl360\sa240\partightenfactor0

\b\fs32 \cf2 Difficulty: 
\f2\b0 Easy\uc0\u8232 Extend your linked list class with a new method that returns the node at the mid point of the 
\f1\fs24 \

\f2\fs32 linked list using no more than one loop. 
\f1\fs24 \

\b\fs32 Tip: 
\f2\b0 If the linked list contains an even number of items, returning the one before or the one after the center is acceptable. 
\f1\fs24 \
\pard\pardeftab720\sl440\sa240\partightenfactor0

\f0\b\fs37\fsmilli18667 \cf2 Sample input and output 
\f1\b0\fs24 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl360\sa320\partightenfactor0
\ls1\ilvl0
\f2\fs32 \cf2 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
If the linked list contains 1, 2, 3, 4, 5, your method should return 3. \uc0\u8232 \
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
If the linked list contains 1, 2, 3, 4, your method may return 2 or 3. \uc0\u8232 \
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
If the linked list contains the English alphabet, your method may return M or N. \uc0\u8232 
\f0\b\fs37\fsmilli18667 Hints 
\f2\b0\fs32 \uc0\u8232 
\f1\b Hint #1: 
\f2\b0 It\'92s easy to solve this in two passes, but only fractionally harder to solve it in one. 
\f1\b Hint #2: 
\f2\b0 If you use fast enumeration \'96 
\f3\b \cf3 for i in items 
\f2\b0 \cf2 \'96 you move over one item at a \uc0\u8232 time. Can you think of a way of moving over more than one item? \u8232 
\f1\b Hint #3: 
\f2\b0 Once you pull out two items at the same time, you can make them move at different speeds through the list. \uc0\u8232 
\f1\b Hint #4: 
\f2\b0 If you move pointer A through the list one item at a time, and pointer B through the list two items at a time, by the time pointer B reaches the end where will pointer A be? \uc0\u8232 
\f0\b\fs37\fsmilli18667 Solution 
\f2\b0\fs32 \uc0\u8232 Moving through collections at different speeds is a useful way to solve many problems, including this one and another coming soon. \u8232 In this case, the clue is in the challenge description: we aren\'92t allowed to use more than one loop, so we have no way of knowing where the middle of the loop is unless we look ahead. Fortunately, the end of the linked list is more or less twice as far as the half-way point \'96 that\'92s obvious when you think about it, although it 
\f1\i is 
\f2\i0 more or less because even-numbered lists don\'92t have a precise center. So, to find the center of a linked list we need to create two pointers: a slow-moving one and a fast-moving one. We can then start our loop: for as long as the fast pointer is not nil, and its 
\f3\b \cf3 next 
\f2\b0 \cf2 node is also not nil, we\'92ll move it forward two places. At the same time, we\'92ll move the slow pointer forward one. When the loop finishes \'96 i.e., when either the fast pointer is nil or its next value is nil \'96 we\'92ve reached the end, at which point the slow pointer contains our center point. 
\f1\fs24 \
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f2\fs32 \cf2 Here\'92s my solution: 
\f1\fs24 \
\pard\pardeftab720\sl360\partightenfactor0

\f4\fs32 \cf4 \cb5 var \cf2 centerNode\cf6 : \cf7 LinkedListNode\cf8 <\cf2 T\cf8 >? \cf6 \{\
\cf4    var \cf2 slow \cf8 = \cf2 start\
\cf4    var \cf2 fast \cf8 = \cf2 start\
\cf4    while \cf2 fast \cf8 != \cf9 nil \cf8 && \cf2 fast\cf8 ?\cf6 .\cf2 next \cf8 != \cf9 nil \cf6 \{\
\cf2       slow \cf8 = \cf2 slow\cf8 ?\cf6 .\cf2 next\
      fast \cf8 = \cf2 fast\cf8 ?\cf6 .\cf2 next\cf8 ?\cf6 .\cf2 next\
\pard\pardeftab720\sl360\sa240\partightenfactor0
\cf6 \} 
\f1\fs24 \cf2 \cb1 \
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f4\fs32 \cf4 \cb5 return \cf2 slow \cf6 \} 
\f1\fs24 \cf2 \cb1 \
}