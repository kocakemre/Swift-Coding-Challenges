{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf810
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\froman\fcharset0 Times-Roman;\f2\froman\fcharset0 TimesNewRomanPSMT;
\f3\fmodern\fcharset0 Courier-Bold;\f4\fmodern\fcharset0 Courier;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red0\green0\blue120;\red163\green0\blue79;
\red255\green255\blue255;\red148\green108\blue71;\red135\green135\blue135;\red73\green17\blue135;\red107\green0\blue109;
\red0\green0\blue255;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;\cssrgb\c0\c0\c54510;\cssrgb\c70588\c0\c38431;
\cssrgb\c100000\c100000\c100000;\cssrgb\c65098\c49804\c34902;\cssrgb\c60000\c60000\c60000;\cssrgb\c36078\c14902\c60000;\cssrgb\c50196\c0\c50196;
\cssrgb\c0\c0\c100000;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\margl1440\margr1440\vieww15300\viewh16500\viewkind0
\deftab720
\pard\pardeftab720\sl560\sa240\partightenfactor0

\f0\b\fs48 \cf2 \expnd0\expndtw0\kerning0
Challenge 49: Sum the even repeats 
\f1\b0\fs24 \
\pard\pardeftab720\sl360\sa240\partightenfactor0

\b\fs32 \cf2 Difficulty: 
\f2\b0 Tricky\uc0\u8232 Write a function that accepts a variadic array of integers and return the sum of all numbers that 
\f1\fs24 \

\f2\fs32 appear an even number of times. 
\f1\fs24 \
\pard\pardeftab720\sl440\sa240\partightenfactor0

\f0\b\fs37\fsmilli18667 \cf2 Sample input and output 
\f1\b0\fs24 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl360\sa320\partightenfactor0
\ls1\ilvl0
\f2\fs32 \cf2 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
The code 
\f3\b \cf3 challenge49(1, 2, 2, 3, 3, 4) 
\f2\b0 \cf2 should return 5, because the numbers 2 and 3 appear twice each. \uc0\u8232 \
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
The code 
\f3\b \cf3 challenge49(5, 5, 5, 12, 12) 
\f2\b0 \cf2 should return 12, because that\'92s the only number that appears an even number of times. \uc0\u8232 \
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
The code challenge49(1, 1, 2, 2, 3, 3, 4, 4)` should return 10. \uc0\u8232 
\f0\b\fs37\fsmilli18667 Hints 
\f2\b0\fs32 \uc0\u8232 
\f1\b Hint #1: 
\f2\b0 This is a perfect use for 
\f3\b \cf3 NSCountedSet
\f2\b0 \cf2 .\uc0\u8232 
\f1\b Hint #2: 
\f2\b0 But: 
\f3\b \cf3 NSCountedSet 
\f2\b0 \cf2 doesn\'92t use generics, so you\'92ll need to typecast somehow. \uc0\u8232 Expect to be judged on your method of typecasting! \u8232 
\f1\b Hint #3: 
\f2\b0 You\'92ll need to use modulus to find numbers that are repeated an even number of times. \uc0\u8232 
\f1\b Hint #4: 
\f2\b0 You\'92ll need to declare your parameter as 
\f3\b \cf3 numbers: Int...
\f2\b0 \cf2 . \uc0\u8232 
\f0\b\fs37\fsmilli18667 Solution 
\f2\b0\fs32 \uc0\u8232 This is really three problems in one: count items in an array, select specific counts, and sum them. None of those are hard by themselves, but combined I think the whole challenge warrants a tricky grade because it can be hard to know where to start. \u8232 Fortunately, we have 
\f3\b \cf3 NSCountedSet
\f2\b0 \cf2 , my personal favorite Foundation data type. This will do the hard work counting items in an array, so all we have to do is run through all its results to find those that have even counts. One fly in the ointment is tat 
\f3\b \cf3 NSCountedSet 
\f2\b0 \cf2 doesn\'92t support generics, so you\'92ll need to either typecast the whole thing or individual elements as you need them. Given that we know we\'92re creating the 
\f3\b \cf3 NSCountedSet 
\f2\b0 \cf2 from an array of integers, we could create an integer array like this: 
\f1\fs24 \
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f4\fs32 \cf4 \cb5 let \cf2 array \cf6 = \cf2 countedSet\cf7 .\cf2 allObjects \cf4 as! \cf7 [\cf8 Int\cf7 ]\cb1 \uc0\u8232 
\f2 \cf2 Alternatively, we could avoid creating a new array and instead just typecast each item as we go: 
\f1\fs24 \
\pard\pardeftab720\sl360\partightenfactor0

\f4\fs32 \cf4 \cb5 for case let \cf2 item \cf4 as \cf8 Int \cf4 in \cf2 countedSet \cf7 \{\
   ...\
\pard\pardeftab720\sl360\sa240\partightenfactor0
\cf7 \cb5 \} 
\f1\fs24 \cf2 \cb1 \
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f2\fs32 \cf2 It\'92s tempting to imagine the former is faster, but it\'92s rarely a good idea to create new variables if they aren\'92t really needed. In this case, the cost of bridging between 
\f3\b \cf3 Any 
\f2\b0 \cf2 and 
\f3\b \cf3 Int 
\f2\b0 \cf2 is so small, taking the 
\f3\b \cf3 for case let 
\f2\b0 \cf2 approach ends up being almost 50% faster \'96 and removes the ugly 
\f3\b \cf3 as! 
\f2\b0 \cf2 typecast. 
\f1\fs24 \

\f2\fs32 Here are both solutions in full, starting with typecasting each item in the loop: 
\f1\fs24 \
\pard\pardeftab720\sl360\partightenfactor0

\f4\fs32 \cf4 \cb5 func \cf9 \cb5 challenge49a\cf7 \cb5 (\cf2 numbers\cf7 : \cf8 Int\cf7 ...) \cf6 \cb5 -> \cf8 \cb5 Int \cf7 \{\
\cf4    let \cf2 counted \cf6 \cb5 = \cf9 NSCountedSet\cf7 \cb5 (\cf2 array\cf7 : \cf2 numbers\cf7 )\
\cf4    var \cf2 sum \cf6 \cb5 = \cf10 0\
\cf4 \cb5    for case let \cf2 item \cf4 as \cf8 Int \cf4 in \cf2 counted \cf7 \{\
\cf4       if \cf2 counted\cf7 .\cf9 \cb5 count\cf7 \cb5 (\cf4 for\cf7 : \cf2 item\cf7 ) \cf6 \cb5 % \cf10 2 \cf6 == \cf10 0 \cf7 \cb5 \{\
\pard\pardeftab720\sl360\sa240\partightenfactor0
\cf2 \cb5 sum \cf6 += \cf2 item \cf7 \} 
\f1\fs24 \cf2 \cb1 \

\f4\fs32 \cf7 \cb5 \} 
\f1\fs24 \cf2 \cb1 \

\f4\fs32 \cf4 \cb5 return \cf2 sum 
\f1\fs24 \cf2 \cb1 \

\f4\fs32 \cf7 \cb5 \} 
\f1\fs24 \cf2 \cb1 \
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f2\fs32 \cf2 And here\'92s the slower solution that converts the counted set into an integer array before the loop: 
\f1\fs24 \
\pard\pardeftab720\sl360\partightenfactor0

\f4\fs32 \cf4 \cb5 func \cf9 \cb5 challenge49b\cf7 \cb5 (\cf2 numbers\cf7 : \cf8 Int\cf7 ...) \cf6 \cb5 -> \cf8 \cb5 Int \cf7 \{\
\cf4    let \cf2 counted \cf6 \cb5 = \cf9 NSCountedSet\cf7 \cb5 (\cf2 array\cf7 : \cf2 numbers\cf7 )\
\cf4    let \cf2 array \cf6 \cb5 = \cf2 \cb5 counted\cf7 .\cf2 allObjects \cf4 as! \cf7 [\cf8 Int\cf7 ]\
\cf4    var \cf2 sum \cf6 \cb5 = \cf10 0\
\cf4 \cb5    for \cf2 item \cf4 in \cf2 array \cf7 \{\
\cf4       if \cf2 counted\cf7 .\cf9 \cb5 count\cf7 \cb5 (\cf4 for\cf7 : \cf2 item\cf7 ) \cf6 \cb5 % \cf10 2 \cf6 == \cf10 0 \cf7 \cb5 \{\
\pard\pardeftab720\sl360\sa240\partightenfactor0
\cf2 \cb5 sum \cf6 += \cf2 item \cf7 \} 
\f1\fs24 \cf2 \cb1 \

\f4\fs32 \cf7 \cb5 \} 
\f1\fs24 \cf2 \cb1 \

\f4\fs32 \cf4 \cb5 return \cf2 sum \
\cf7 \} \
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f2 \cf2 \cb1 Getting rid of an unnecessary 
\f3\b \cf3 as! 
\f2\b0 \cf2 typecast always feels good, but in this case the first solution also benefits from using the 
\f3\b \cf3 for case let 
\f2\b0 \cf2 syntax \'96 one of Swift\'92s real gems. 
\f1\fs24 \
\
}