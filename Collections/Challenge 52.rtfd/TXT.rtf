{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf810
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\froman\fcharset0 Times-Roman;\f2\froman\fcharset0 TimesNewRomanPSMT;
\f3\fmodern\fcharset0 Courier-Bold;\f4\fmodern\fcharset0 Courier;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red0\green0\blue120;\red163\green0\blue79;
\red255\green255\blue255;\red148\green108\blue71;\red0\green0\blue255;\red107\green0\blue109;\red135\green135\blue135;
\red169\green0\blue15;\red73\green17\blue135;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;\cssrgb\c0\c0\c54510;\cssrgb\c70588\c0\c38431;
\cssrgb\c100000\c100000\c100000;\cssrgb\c65098\c49804\c34902;\cssrgb\c0\c0\c100000;\cssrgb\c50196\c0\c50196;\cssrgb\c60000\c60000\c60000;
\cssrgb\c72941\c0\c6667;\cssrgb\c36078\c14902\c60000;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid101\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid2}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}}
\margl1440\margr1440\vieww15300\viewh16500\viewkind0
\deftab720
\pard\pardeftab720\sl560\sa240\partightenfactor0

\f0\b\fs48 \cf2 \expnd0\expndtw0\kerning0
Challenge 52: Sum an array of numbers 
\f1\b0\fs24 \
\pard\pardeftab720\sl360\sa240\partightenfactor0

\b\fs32 \cf2 Difficulty: 
\f2\b0 Taxing\uc0\u8232 Write one function that sums an array of numbers. The array might contain all integers, all 
\f1\fs24 \

\f2\fs32 doubles, or all floats. 
\f1\fs24 \

\b\fs32 Tip: 
\f2\b0 If you think this challenge is easy, you\'92re either a hardened Swift pro or you\'92ve underestimated the problem. 
\f1\fs24 \
\pard\pardeftab720\sl440\sa240\partightenfactor0

\f0\b\fs37\fsmilli18667 \cf2 Sample input and output 
\f1\b0\fs24 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl360\sa320\partightenfactor0
\ls1\ilvl0
\f2\fs32 \cf2 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
The code 
\f3\b \cf3 challenge52(numbers: [1, 2, 3]) 
\f2\b0 \cf2 should return 6. \uc0\u8232 \
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
The code 
\f3\b \cf3 challenge52(numbers: [1.0, 2.0, 3.0]) 
\f2\b0 \cf2 should return 6.0. \uc0\u8232 \
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
The code 
\f3\b \cf3 challenge52(numbers: Array<Float>([1.0, 2.0, 3.0])) 
\f2\b0 \cf2 \uc0\u8232 should return 6.0. \u8232 
\f0\b\fs37\fsmilli18667 Hints 
\f2\b0\fs32 \uc0\u8232 
\f1\b Hint #1: 
\f2\b0 If this were just about counting integers this would definitely be an easy grade. 
\f1\b Hint #2: 
\f2\b0 This function needs to work with multiple data types, so you\'92ll need to use generics \uc0\u8232 with a constraint.\u8232 
\f1\b Hint #3: 
\f2\b0 There\'92s no built-in protocol that covers integers, floats, and doubles, so you\'92ll need to \uc0\u8232 create your own then extend 
\f3\b \cf3 Int
\f2\b0 \cf2 , 
\f3\b \cf3 Float
\f2\b0 \cf2 , and 
\f3\b \cf3 Double 
\f2\b0 \cf2 using it.\uc0\u8232 
\f1\b Hint #4: 
\f2\b0 Your protocol needs to be able to initialize itself with an empty value, and add two \uc0\u8232 instances of itself.\u8232 
\f1\b Hint #5: 
\f2\b0 Once you have everything in place, you can solve this challenge functionally. \uc0\u8232 
\f0\b\fs37\fsmilli18667 Solution 
\f2\b0\fs32 \uc0\u8232 This is a great question to ask someone who is interviewing for a senior Swift position, \u8232 because it sounds trivial on the surface but ends up needing to exercise some of Swift\'92s most advanced functionality \'96 not least generics and protocol extensions. Swift doesn\'92t have a single protocol that covers 
\f3\b \cf3 Int
\f2\b0 \cf2 , 
\f3\b \cf3 Float
\f2\b0 \cf2 , and 
\f3\b \cf3 Double 
\f2\b0 \cf2 because they aren\'92t interchangeable things. Even though 
\f3\b \cf3 Double 
\f2\b0 \cf2 uses 64 bits to store its data, and for most people 
\f3\b \cf3 Int 
\f2\b0 \cf2 does the same, they work differently internally so it\'92s not safe to use them interchangeably. 
\f1\fs24 \
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f2\fs32 \cf2 For example, consider this code: 
\f1\fs24 \
\pard\pardeftab720\sl360\partightenfactor0

\f4\fs32 \cf4 \cb5 let \cf2 int \cf6 = \cf7 9223372036854775798\
\cf4 let \cf2 double \cf6 = \cf8 Double\cf9 (\cf2 int\cf9 )\
\cf8 print\cf9 (\cf8 String\cf9 (\cf2 format\cf9 :\cf10 "Int is %ld"\cf9 , \cf2 int\cf9 ))\
\cf8 print\cf9 (\cf8 String\cf9 (\cf2 format\cf9 :\cf10 "Double is %.0f"\cf9 , \cf2 double\cf9 ))\
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f2 \cf2 \cb1 That prints out both numbers in full, but if you run it you\'92ll see the double is equal to 9223372036854775808 \'96 it\'92s 10 higher. 
\f1\fs24 \

\f2\fs32 So, Swift quite rightly refuses to treat them interchangeably, because they can\'92t be converted safely. However, if we restrict our function to working with one specific type at a time, we can make this work. 
\f1\fs24 \

\f2\fs32 This involves a number of steps: 
\f1\fs24 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl360\sa320\partightenfactor0
\ls2\ilvl0
\f2\fs32 \cf2 \kerning1\expnd0\expndtw0 {\listtext	1.	}\expnd0\expndtw0\kerning0
Creating a new protocol that requires implementers to be able to initialize themselves with an empty value and add instances of itself to itself. \uc0\u8232 \
\ls2\ilvl0\kerning1\expnd0\expndtw0 {\listtext	2.	}\expnd0\expndtw0\kerning0
Extend 
\f3\b \cf3 Int
\f2\b0 \cf2 , 
\f3\b \cf3 Float
\f2\b0 \cf2 , and 
\f3\b \cf3 Double 
\f2\b0 \cf2 to conform to that protocol. \uc0\u8232 \
\ls2\ilvl0\kerning1\expnd0\expndtw0 {\listtext	3.	}\expnd0\expndtw0\kerning0
Create a function that uses generics to accept an array of types conforming to that \uc0\u8232 protocol. \u8232 \
\ls2\ilvl0\kerning1\expnd0\expndtw0 {\listtext	4.	}\expnd0\expndtw0\kerning0
Sum the numbers. \uc0\u8232 \
\pard\pardeftab720\sl360\sa240\partightenfactor0
\cf2 Each of those can be tackled individually, although there are two ways to tackle step 4 \'96 and I\'92ll be showing you both, naturally. 
\f1\fs24 \

\f2\fs32 First, creating a new protocol that requires conforming types to be able to initialize themselves with an empty value (i.e. 0) and add instances of itself to itself: 
\f1\fs24 \
\pard\pardeftab720\sl360\partightenfactor0

\f4\fs32 \cf2 \cb5 protocol \cf11 \cb5 Numeric \cf9 \cb5 \{\
\cf4    init\cf9 ()\
\cf4    static func \cf6 +\cf9 (\cf2 lhs\cf9 : \cf4 Self\cf9 , \cf2 rhs\cf9 : \cf4 Self\cf9 ) \cf6 -> \cf4 Self\
\cf9 \}\
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f2 \cf2 \cb1 Second, making 
\f3\b \cf3 Int
\f2\b0 \cf2 , 
\f3\b \cf3 Float
\f2\b0 \cf2 , and 
\f3\b \cf3 Double 
\f2\b0 \cf2 conform to that protocol: 
\f1\fs24 \
\pard\pardeftab720\sl360\partightenfactor0

\f4\fs32 \cf4 \cb5 extension \cf11 \cb5 Int\cf9 \cb5 : \cf11 \cb5 Numeric \cf9 \cb5 \{\}\
\cf4 extension \cf11 \cb5 Float\cf9 \cb5 : \cf11 \cb5 Numeric \cf9 \cb5 \{\}\
\cf4 extension \cf11 \cb5 Double\cf9 \cb5 : \cf11 \cb5 Numeric \cf9 \cb5 \{\}\
\
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f2 \cf2 \cb1 The implementations are empty because all three of those types satisfy the protocol\'92s requirements already. 
\f1\fs24 \

\f2\fs32 Third, defining a function that accepts an array of numbers that conform to 
\f3\b \cf3 Numeric 
\f2\b0 \cf2 and returns a single value: 
\f1\fs24 \
\pard\pardeftab720\sl360\partightenfactor0

\f4\fs32 \cf4 func \cf2 challenge52\cf6 <\cf2 T\cf9 : \cf11 Numeric\cf6 >\cf9 (\cf2 numbers\cf9 : [\cf2 T\cf9 ]) \cf6 -> \cf2 T \cf9 \{\
\}\
\
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f2 \cf2 Finally, step four is adding the array\'92s numbers together. This can be done using a simple loop, like this: 
\f1\fs24 \
\pard\pardeftab720\sl360\partightenfactor0

\f4\fs32 \cf4 \cb5 var \cf2 total \cf6 = \cf8 T\cf9 ()\
\cf4 for \cf2 number \cf4 in \cf2 numbers \cf9 \{\
\cf2    total \cf6 = \cf2 total \cf6 + \cf2 number\
\pard\pardeftab720\sl360\sa240\partightenfactor0
\cf9 \cb5 \} 
\f1\fs24 \cf2 \cb1 \
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f4\fs32 \cf4 \cb5 return \cf2 total 
\f1\fs24 \cf2 \cb1 \
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f2\fs32 \cf2 Alternatively you can make it a functional one-liner using 
\f3\b \cf3 reduce()
\f2\b0 \cf2 : 
\f4 \cf4 \cb5 return \cf2 numbers\cf9 .\cf8 reduce\cf9 (\cf8 T\cf9 (), \cf6 +\cf9 ) 
\f1\fs24 \cf2 \cb1 \
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f4\fs32 \cf4 \cb5 return \cf2 numbers\cf9 .\cf8 reduce\cf9 (\cf8 T\cf9 (), \cf6 +\cf9 ) 
\f1\fs24 \cf2 \cb1 \
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f2\fs32 \cf2 Done! 
\f1\fs24 \

\f2\fs32 There is one partial alternative that\'92s worth tossing into the mix, which is Apple\'92s Accelerate framework. This is a massive library of optimized mathematics routines that is incredibly fast at doing selected tasks. In the context of this challenge, Accelerate is able to add doubles and floats extremely quickly \'96 easily twice as fast as the fastest solution above, and perhaps four or five times as fast depending on what you feed it. 
\f1\fs24 \

\f2\fs32 There are downsides to using Accelerate. First, it works on floats and doubles but not integers, so it\'92s not suitable for the generic approach used here. Second, it works best when it has a lot of data: if you\'92re summing only 10 numbers it will probably work out slower, but sum 100 or more and it will fly. Third, and most crucially, it is one of the least approachable APIs in all of Apple-land, so it takes a little getting used to. 
\f1\fs24 \

\f2\fs32 Anyway, in case you were curious, here\'92s the Accelerate way to sum an array of doubles: 
\f1\fs24 \
\pard\pardeftab720\sl360\partightenfactor0

\f4\fs32 \cf4 \cb5 func \cf8 challenge52c\cf9 (\cf2 numbers\cf9 : [\cf11 \cb5 Double\cf9 \cb5 ]) \cf6 -> \cf11 \cb5 Double \cf9 \cb5 \{\
\cf4    var \cf2 result\cf9 : \cf11 \cb5 Double \cf6 \cb5 = \cf7 0.0\
\cf8    vDSP_sveD\cf9 (\cf2 numbers\cf9 , \cf7 1\cf9 , \cf6 &\cf2 result\cf9 , \cf8 vDSP_Length\cf9 (\cf2 numbers\cf9 .\cf11 \cb5 count\cf9 \cb5 ))\
\cf4    return \cf2 result\
\pard\pardeftab720\sl360\sa240\partightenfactor0
\cf9 \cb5 \} 
\f1\fs24 \cf2 \cb1 \
}