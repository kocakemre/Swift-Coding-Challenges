{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf810
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\froman\fcharset0 Times-Roman;\f2\froman\fcharset0 TimesNewRomanPSMT;
\f3\fmodern\fcharset0 Courier-Bold;\f4\fmodern\fcharset0 Courier;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red0\green0\blue120;\red163\green0\blue79;
\red255\green255\blue255;\red148\green108\blue71;\red135\green135\blue135;\red73\green17\blue135;\red0\green0\blue255;
\red169\green0\blue15;\red107\green0\blue109;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;\cssrgb\c0\c0\c54510;\cssrgb\c70588\c0\c38431;
\cssrgb\c100000\c100000\c100000;\cssrgb\c65098\c49804\c34902;\cssrgb\c60000\c60000\c60000;\cssrgb\c36078\c14902\c60000;\cssrgb\c0\c0\c100000;
\cssrgb\c72941\c0\c6667;\cssrgb\c50196\c0\c50196;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\margl1440\margr1440\vieww15300\viewh16500\viewkind0
\deftab720
\pard\pardeftab720\sl560\sa240\partightenfactor0

\f0\b\fs48 \cf2 \expnd0\expndtw0\kerning0
Challenge 43: Linked lists 
\f1\b0\fs24 \
\pard\pardeftab720\sl360\sa240\partightenfactor0

\b\fs32 \cf2 Difficulty: 
\f2\b0 Easy\uc0\u8232 Create a linked list of lowercase English alphabet letters, along with a method that traverses all 
\f1\fs24 \

\f2\fs32 nodes and prints their letters on a single line separated by spaces. 
\f1\fs24 \

\b\fs32 Tip #1: 
\f2\b0 This is several problems in one. First, create a linked list data structure, which itself is really two things. Second, use your linked list to create the alphabet. Third, write a method traverses all nodes and prints their letters. 
\f1\fs24 \

\b\fs32 Tip #2: 
\f2\b0 You should use a class for this. Yes, really.\uc0\u8232 
\f1\b Tip #3: 
\f2\b0 Once you complete your solution, keep a copy of the code \'96 you\'92ll need it for future 
\f1\fs24 \

\f2\fs32 challenges! 
\f1\fs24 \
\pard\pardeftab720\sl440\sa240\partightenfactor0

\f0\b\fs37\fsmilli18667 \cf2 Sample input and output 
\f1\b0\fs24 \
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f2\fs32 \cf2 \'95 The output of your code should be the English alphabet printed to the screen, i.e. \'93a b c d ... x y z\'94. 
\f1\fs24 \
\pard\pardeftab720\sl440\sa240\partightenfactor0

\f0\b\fs37\fsmilli18667 \cf2 Hints 
\f1\b0\fs24 \
\pard\pardeftab720\sl360\sa240\partightenfactor0

\b\fs32 \cf2 Hint #1: 
\f2\b0 If your first instinct was to create your new data types as a struct, it shows you\'92re a sound Swift developer. Sadly, I\'92m afraid that approach won\'92t work here because structs can\'92t have stored properties that reference themselves. 
\f1\fs24 \

\b\fs32 Hint #2: 
\f2\b0 Your second instinct might be to use an enum. This makes creation tricksy because you would need to change the associated value after creating the enum. 
\f1\fs24 \

\b\fs32 Hint #3: 
\f2\b0 Even though this challenge uses alphabet letters, aim to make your class generic \'96 it shows smart forward thinking, and is only fractionally harder than using a specific data type. 
\f1\fs24 \

\b\fs32 Hint #4: 
\f2\b0 There are lots of hacky ways to loop over the alphabet. The only sensible way is to use 
\f3\b \cf3 "abcdefghijklmnopqrstuvwxyz".characters 
\f2\b0 \cf2 \'96 it\'92s not hard to write, is self- documenting, and quite safe. 
\f1\fs24 \

\b\fs32 Hint #5: 
\f2\b0 You should create two data types: one for a node, which contains its character and link to the next node in the list, and one for the overall linked list, which contains a property for the first node in the list as well as the print method. 
\f1\fs24 \

\b\fs32 Hint #6: 
\f2\b0 The 
\f3\b \cf3 print() 
\f2\b0 \cf2 function has a 
\f3\b \cf3 terminator 
\f2\b0 \cf2 parameter. 
\f1\fs24 \
\pard\pardeftab720\sl440\sa240\partightenfactor0

\f0\b\fs37\fsmilli18667 \cf2 Solution 
\f1\b0\fs24 \
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f2\fs32 \cf2 Linked lists are a simple data structure that you ought to be able to code from scratch in a couple of minutes. At first it\'92s easy to see them as hobbled arrays, but the truth is they have their own advantages and disadvantages just like any data structure. 
\f1\fs24 \

\f2\fs32 For example, if you want to insert a new value into the middle of an array, the 
\f3\b \cf3 insert() 
\f2\b0 \cf2 method is O(n) \'96 it takes longer and longer depending on the size of the array. This is because Swift has to move other items down one space before inserting the new item. In comparison, inserting something into the middle of a linked list is O(1) because you just change two pointers. On the other hand, jumping to an arbitrary position in an array is O(1), whereas it\'92s O(n) in a linked list because you need to start at the first node and work your way down the chain. 
\f1\fs24 \

\f2\fs32 Let\'92s jump in to the solution, starting with a custom class to handle nodes: 
\f1\fs24 \
\pard\pardeftab720\sl360\partightenfactor0

\f4\fs32 \cf4 \cb5 class \cf2 LinkedListNode\cf6 <\cf2 T\cf6 > \cf7 \{\
\cf4    var \cf2 value\cf7 : \cf2 T\
\cf4    var \cf2 next\cf7 : \cf8 LinkedListNode\cf6 ?\
\cf4    init\cf7 (\cf2 value\cf7 : \cf2 T\cf7 ) \{\
\cf4       self\cf7 .\cf2 value \cf6 = \cf2 value\
\pard\pardeftab720\sl360\sa240\partightenfactor0
\cf7 \} \
\} 
\f1\fs24 \cf2 \cb1 \
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f2\fs32 \cf2 So, each node has a value, as well as an optional link to its successor. In the initializer we only set the value, because we\'92ll be setting the 
\f3\b \cf3 next 
\f2\b0 \cf2 property after creation. 
\f1\fs24 \

\f2\fs32 Wrapping that node type in a parent class is trivial: 
\f1\fs24 \
\pard\pardeftab720\sl360\partightenfactor0

\f4\fs32 \cf4 \cb5 class \cf2 LinkedList\cf6 <\cf2 T\cf6 > \cf7 \{\
\cf4    var \cf2 start\cf7 : \cf8 LinkedListNode\cf6 <\cf2 T\cf6 >?\
\pard\pardeftab720\sl360\sa240\partightenfactor0
\cf7 \} 
\f1\fs24 \cf2 \cb1 \
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f2\fs32 \cf2 We\'92ll come back to that soon to add a 
\f3\b \cf3 printNodes() 
\f2\b0 \cf2 method.\uc0\u8232 In order to create our linked list, we\'92re going to start by creating two variables: 
\f1\fs24 \
\pard\pardeftab720\sl360\partightenfactor0

\f4\fs32 \cf4 var \cf2 list \cf6 = \cf8 LinkedList\cf6 <\cf8 Character\cf6 >\cf7 ()\
\cf4 var \cf2 previousNode\cf7 : \cf8 LinkedListNode\cf6 <\cf8 Character\cf6 >? = \cf9 nil\
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f2 \cf2 The 
\f3\b \cf3 previousNode 
\f2\b0 \cf2 will be used to create our chain \'96 each time we get a letter to create, we\'92ll see the 
\f3\b \cf3 next 
\f2\b0 \cf2 property of 
\f3\b \cf3 previousNode 
\f2\b0 \cf2 to the most recently created node. 
\f1\fs24 \

\f2\fs32 This is all done using a loop. As I said in the hints, the smartest way to loop over the letters of the alphabet is just to type them in a string and use its 
\f3\b \cf3 characters 
\f2\b0 \cf2 property. 
\f1\fs24 \

\f2\fs32 Inside the loop we\'92ll create a new 
\f3\b \cf3 LinkedListNode 
\f2\b0 \cf2 for the current letter. If 
\f3\b \cf3 previousNode 
\f2\b0 \cf2 is nil it means this is the first letter to be created, so we\'92ll set 
\f3\b \cf3 list.start 
\f2\b0 \cf2 to be the new node. Otherwise we have a predecessor \'96 the node that should link to this new node \'96 so we\'92ll update its 
\f3\b \cf3 next 
\f2\b0 \cf2 property to point at the new node. 
\f1\fs24 \

\f2\fs32 Here\'92s all that in code: 
\f1\fs24 \
\pard\pardeftab720\sl360\partightenfactor0

\f4\fs32 \cf4 \cb5 for \cf2 letter \cf4 in \cf10 \cb5 "abcdefghijklmnopqrstuvwxyz"\cf7 \cb5 .\cf2 characters \cf7 \{\
\cf4    let \cf2 node \cf6 = \cf11 \cb5 LinkedListNode\cf7 \cb5 (\cf2 value\cf7 : \cf2 letter\cf7 )\
\cf4    if let \cf2 predecessor \cf6 = \cf2 previousNode \cf7 \{\
\cf2       predecessor\cf7 .\cf2 next \cf6 = \cf2 node\
\cf7    \} \cf4 else \cf7 \{\
\cf2       list\cf7 .\cf2 start \cf6 = \cf2 node\
\pard\pardeftab720\sl360\sa240\partightenfactor0
\cf7 \} 
\f1\fs24 \cf2 \cb1 \
\pard\pardeftab720\sl360\partightenfactor0

\f4\fs32 \cf2 \cb5    previousNode \cf6 = \cf2 node\
\pard\pardeftab720\sl360\sa240\partightenfactor0
\cf7 \} 
\f1\fs24 \cf2 \cb1 \
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f2\fs32 \cf2 So, at this point we\'92ve accomplished two of the three parts to this challenge: we\'92ve created our own linked list data type, and created a list out of the alphabet. All that remains is traversing the list to print out all its values on a single line, separated by spaces. 
\f1\fs24 \

\f2\fs32 Once you know that the 
\f3\b \cf3 print() 
\f2\b0 \cf2 function has a 
\f3\b \cf3 terminator 
\f2\b0 \cf2 parameter that lets you specify something other than a line break to use after the line is printed, this method is pretty straightforward: 
\f1\fs24 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl360\sa320\partightenfactor0
\ls1\ilvl0
\f2\fs32 \cf2 \kerning1\expnd0\expndtw0 {\listtext	1.	}\expnd0\expndtw0\kerning0
Pick out the first node in the list using the 
\f3\b \cf3 start 
\f2\b0 \cf2 property and make that the current node. \uc0\u8232 \
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	2.	}\expnd0\expndtw0\kerning0
While the current node is not nil, print out its value with a space for the terminator. \uc0\u8232 \
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	3.	}\expnd0\expndtw0\kerning0
Update the current node to be equal to the value of its 
\f3\b \cf3 next 
\f2\b0 \cf2 property, thereby moving \uc0\u8232 to the next element in the list. \u8232 \
\pard\pardeftab720\sl360\sa240\partightenfactor0
\cf2 That\'92s it! Here\'92s the code: 
\f1\fs24 \
\pard\pardeftab720\sl360\partightenfactor0

\f4\fs32 \cf4 \cb5 func \cf11 \cb5 printNodes\cf7 \cb5 () \{\
\cf4    var \cf2 currentNode \cf6 = \cf2 start\
\cf4    while let \cf2 node \cf6 = \cf2 currentNode \cf7 \{\
\pard\pardeftab720\sl360\partightenfactor0
\cf11 \cb5       print\cf7 \cb5 (\cf2 node\cf7 .\cf2 value\cf7 , \cf2 terminator\cf7 : \cf10 \cb5 " "\cf7 \cb5 )\
\pard\pardeftab720\sl360\partightenfactor0
\cf2       currentNode \cf6 = \cf2 node\cf7 .\cf2 next\
\pard\pardeftab720\sl360\sa240\partightenfactor0
\cf7 \} \
\} 
\f1\fs24 \cf2 \cb1 \
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f2\fs32 \cf2 For reference, here\'92s my complete solution to this challenge: 
\f1\fs24 \
\pard\pardeftab720\sl360\partightenfactor0

\f4\fs32 \cf4 \cb5 class \cf2 LinkedListNode\cf6 <\cf2 T\cf6 > \cf7 \{\
\cf4    var \cf2 value\cf7 : \cf2 T\
\cf4    var \cf2 next\cf7 : \cf8 LinkedListNode\cf6 ?\
\cf4    init\cf7 (\cf2 value\cf7 : \cf2 T\cf7 ) \{\
\cf4       self\cf7 .\cf2 value \cf6 = \cf2 value\
\pard\pardeftab720\sl360\sa240\partightenfactor0
\cf7 \} \
\} 
\f1\fs24 \cf2 \cb1 \
\pard\pardeftab720\sl360\partightenfactor0

\f4\fs32 \cf4 \cb5 class \cf2 LinkedList\cf6 <\cf2 T\cf6 > \cf7 \{\
\cf4    var \cf2 start\cf7 : \cf8 LinkedListNode\cf6 <\cf2 T\cf6 >?\
\cf4    func \cf11 \cb5 printNodes\cf7 \cb5 () \{\
\cf4       var \cf2 currentNode \cf6 = \cf2 start\
\cf4       while let \cf2 node \cf6 = \cf2 currentNode \cf7 \{\
\pard\pardeftab720\sl360\partightenfactor0
\cf11 \cb5          print\cf7 \cb5 (\cf2 node\cf7 .\cf2 value\cf7 , \cf2 terminator\cf7 : \cf10 \cb5 " "\cf7 \cb5 )\
\pard\pardeftab720\sl360\partightenfactor0
\cf2          currentNode \cf6 = \cf2 node\cf7 .\cf2 next\
\pard\pardeftab720\sl360\sa240\partightenfactor0
\cf7 \} \
\} 
\f1\fs24 \cf2 \cb1 \
\pard\pardeftab720\sl360\partightenfactor0

\f4\fs32 \cf7 \cb5 \}\
\cf4 var \cf2 list \cf6 = \cf8 LinkedList\cf6 <\cf8 Character\cf6 >\cf7 ()\
\cf4 var \cf2 previousNode\cf7 : \cf8 LinkedListNode\cf6 <\cf8 Character\cf6 >? = \cf9 \cb5 nil\
\cf4 \cb5 for \cf2 letter \cf4 in \cf10 \cb5 "abcdefghijklmnopqrstuvwxyz"\cf7 \cb5 .\cf2 characters \cf7 \{\
\cf4    let \cf2 node \cf6 = \cf11 \cb5 LinkedListNode\cf7 \cb5 (\cf2 value\cf7 : \cf2 letter\cf7 )\
\cf4    if let \cf2 predecessor \cf6 = \cf2 previousNode \cf7 \{\
\cf2       predecessor\cf7 .\cf2 next \cf6 = \cf2 node\
\cf7    \} \cf4 else \cf7 \{\
\cf2       list\cf7 .\cf2 start \cf6 = \cf2 node\
\pard\pardeftab720\sl360\sa240\partightenfactor0
\cf7 \} 
\f1\fs24 \cf2 \cb1 \
\pard\pardeftab720\sl360\partightenfactor0

\f4\fs32 \cf2 \cb5    previousNode \cf6 = \cf2 node\
\cf7 \}\
\cf2 list\cf7 .\cf11 \cb5 printNodes\cf7 \cb5 ()\
}