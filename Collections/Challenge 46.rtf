{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf810
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\froman\fcharset0 Times-Roman;\f2\froman\fcharset0 TimesNewRomanPSMT;
\f3\fmodern\fcharset0 Courier-Bold;\f4\fmodern\fcharset0 Courier;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red0\green0\blue120;\red28\green117\blue20;
\red255\green255\blue255;\red163\green0\blue79;\red73\green17\blue135;\red135\green135\blue135;\red148\green108\blue71;
\red0\green0\blue255;\red107\green0\blue109;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;\cssrgb\c0\c0\c54510;\cssrgb\c11373\c52157\c9804;
\cssrgb\c100000\c100000\c100000;\cssrgb\c70588\c0\c38431;\cssrgb\c36078\c14902\c60000;\cssrgb\c60000\c60000\c60000;\cssrgb\c65098\c49804\c34902;
\cssrgb\c0\c0\c100000;\cssrgb\c50196\c0\c50196;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid101\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid2}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}}
\margl1440\margr1440\vieww15300\viewh16500\viewkind0
\deftab720
\pard\pardeftab720\sl560\sa240\partightenfactor0

\f0\b\fs48 \cf2 \expnd0\expndtw0\kerning0
Challenge 46: Recreate map() 
\f1\b0\fs24 \
\pard\pardeftab720\sl360\sa240\partightenfactor0

\b\fs32 \cf2 Difficulty: 
\f2\b0 Tricky\uc0\u8232 Write an extension for all collections that reimplements the 
\f3\b \cf3 map() 
\f2\b0 \cf2 method. 
\f1\fs24 \
\pard\pardeftab720\sl440\sa240\partightenfactor0

\f0\b\fs37\fsmilli18667 \cf2 Sample input and output 
\f1\b0\fs24 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl360\sa320\partightenfactor0
\ls1\ilvl0
\f2\fs32 \cf2 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
The code 
\f3\b \cf3 [1, 2, 3].challenge46 \{ String($0) \} 
\f2\b0 \cf2 should return 
\f3\b \cf3 [\'931\'94, "2", "3"] 
\f2\b0 \cf2 \uc0\u8232 \
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
The code 
\f3\b \cf3 ["1", "2", "3"].challenge46 \{ Int($0)! \} 
\f2\b0 \cf2 should return 
\f3\b \cf3 [1, 2, 3]
\f2\b0 \cf2 . \uc0\u8232 
\f0\b\fs37\fsmilli18667 Hints 
\f2\b0\fs32 \uc0\u8232 
\f1\b Hint #1: 
\f2\b0 You\'92ll need to extend the 
\f3\b \cf3 Collection 
\f2\b0 \cf2 type.\uc0\u8232 
\f1\b Hint #2: 
\f2\b0 Your transformation function should accept a parameter of type \uc0\u8232 
\f3\b \cf3 Iterator.Element
\f2\b0 \cf2 , but must return a generic parameter.\uc0\u8232 
\f1\b Hint #3: 
\f2\b0 You should accept transformation functions that throw, but you don\'92t want to handle \uc0\u8232 any exceptions in your mapping method.\u8232 
\f1\b Hint #4: 
\f2\b0 Non-throwing functions are sub-types of throwing functions. \uc0\u8232 
\f1\b Hint #5: 
\f2\b0 You really ought to use 
\f3\b \cf3 rethrows 
\f2\b0 \cf2 to avoid irritating users who use non-throwing functions. \uc0\u8232 
\f0\b\fs37\fsmilli18667 Solution 
\f2\b0\fs32 \uc0\u8232 This is an easy problem to solve if you\'92re an experienced Swift developer, but tricky or perhaps even taxing if you\'92ve only touched small amounts of the language \'96 anyone who has read Pro Swift ought to have found this a walk in the park! \u8232 \
\pard\pardeftab720\sl360\sa240\partightenfactor0
\cf2 To make a 
\f3\b \cf3 map() 
\f2\b0 \cf2 method truly useful, you need to draw on several of Swift\'92s power features: 
\f1\fs24 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl360\sa320\partightenfactor0
\ls2\ilvl0
\f2\fs32 \cf2 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Generics, because you don\'92t know what kind of data type will be returned. In the example input and output I specifically make the return types be different to the input types. \uc0\u8232 \
\ls2\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Closures, because that\'92s how your transformation function will be specified. \uc0\u8232 \
\ls2\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Throwing and rethrowing functions. The former because the transformation function \uc0\u8232 ought to be able to throw; the latter because you don\'92t want to handle exceptions inside your mapping method, but also don\'92t want to mark the whole method as throwing because that would be annoying at the call site. \u8232 \
\ls2\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Protocol extensions, because you\'92re required to extend all collections, not just arrays or dictionaries. \uc0\u8232 The truly incredible thing is how little code it takes to do all that. \u8232 \
\pard\pardeftab720\sl360\partightenfactor0

\f4 \cf4 \cb5 // extend all collections\
\pard\pardeftab720\sl360\partightenfactor0
\cf6 extension \cf7 Collection \cf8 \{\
\pard\pardeftab720\sl360\partightenfactor0
\cf4    // add a generic method that accepts a closure operating on\
our element type and returns a new type, with the whole method\
returning an array of that type\
\pard\pardeftab720\sl360\partightenfactor0
\cf6    func \cf2 challenge46\cf9 <\cf2 T\cf9 >\cf8 (\cf10 _ \cf2 transform\cf8 : (\cf7 Iterator\cf8 .\cf7 Element\cf8 ) \cf6 throws \cf9 -\
> \cf2 T\cf8 ) \cf6 rethrows \cf9 -> \cf8 [\cf2 T\cf8 ] \{\
\pard\pardeftab720\sl360\partightenfactor0
\cf4       // create the return array\
\pard\pardeftab720\sl360\partightenfactor0
\cf6       var \cf2 returnValue \cf9 = \cf8 [\cf2 T\cf8 ]()\
\pard\pardeftab720\sl360\partightenfactor0
\cf4       // loop over all our items, trying the transformation and\
appending it to our return\
\pard\pardeftab720\sl360\partightenfactor0
\cf6       for \cf2 item \cf6 in self \cf8 \{\
\pard\pardeftab720\sl360\partightenfactor0
\cf2          returnValue\cf8 .\cf11 append\cf8 (\cf6 try \cf11 transform\cf8 (\cf2 item\cf8 ))\
\pard\pardeftab720\sl360\sa240\partightenfactor0
\cf8 \} 
\f1\fs24 \cf2 \cb1 \
\pard\pardeftab720\sl360\partightenfactor0

\f4\fs32 \cf4 \cb5       // send back the return value\
\pard\pardeftab720\sl360\partightenfactor0
\cf6       return \cf2 returnValue\
\cf8    \}\
\pard\pardeftab720\sl360\sa240\partightenfactor0
\cf8 \} 
\f1\fs24 \cf2 \cb1 \
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f2\fs32 \cf2 The only thing that might have thrown you there is the use of \'93throws\'94 and \'93rethrows\'94. This is covered in detail in Pro Swift, but the TL;DR version is this: marking the parameter with 
\f3\b \cf3 throws 
\f2\b0 \cf2 means only that it 
\f1\i might 
\f2\i0 throw, not that it 
\f1\i will 
\f2\i0 throw, and marking the whole thing as 
\f3\b \cf3 rethrows 
\f2\b0 \cf2 means it need be used with 
\f3\b \cf3 try/catch 
\f2\b0 \cf2 only when its parameter really does throw. 
\f1\fs24 \
}